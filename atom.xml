<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默默地向前端靠拢</title>
  <subtitle>你所浪费的今天，是昨天死去的人奢望的明天；你所厌恶的现在，是未来的你回不去的曾经。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-02T09:09:21.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>心情</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS中几种循环的区别与相同点</title>
    <link href="http://yoursite.com/2017/09/02/foreach/"/>
    <id>http://yoursite.com/2017/09/02/foreach/</id>
    <published>2017-09-02T08:34:15.000Z</published>
    <updated>2017-09-02T09:09:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环语句，用于重复执行某个操作，它有多种形式。"><a href="#循环语句，用于重复执行某个操作，它有多种形式。" class="headerlink" title="循环语句，用于重复执行某个操作，它有多种形式。"></a>循环语句，用于重复执行某个操作，它有多种形式。</h1><ol>
<li><p>while循环</p>
<p> while语句的循环条件是一个表达式（express），必须放在圆括号中。代码块部分，如果只有一条语句（statement），可以省略大括号，否则就必须加上大括号。</p>
</li>
</ol>
<a id="more"></a>
<pre><code><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (expression)</div><div class="line">  statement;</div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> (expression) statement;</div></pre></td></tr></table></figure>


下面写个例子



<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'i当前为：'</span> + i);</div><div class="line">  i += <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>




上面的代码将循环100次，直到i等于100为止。

下面的例子是一个无限循环，因为条件总是为真。



<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, world'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><ol>
<li><p>for循环</p>
<p> for语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (initialize; test; increment)</div><div class="line">  statement</div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (initialize; test; increment) &#123;</div><div class="line">  statement</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>for语句后面的括号里面，有三个表达式。
&gt; * 初始化表达式（initialize）：确定循环的初始值，只在循环开始时执行一次。
&gt; * 测试表达式（test）：检查循环条件，只要为真就进行后续操作。
&gt; * 递增表达式（increment）：完成后续操作，然后返回上一步，再一次检查循环条件。

eg:
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div></pre></td></tr></table></figure>
<pre><code>上面代码中，初始化表达式是var i = 0，即初始化一个变量i；测试表达式是i &lt; x，即只要i小于x，就会执行循环；递增表达式是i++，即每次循环结束后，i增大1。

所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (i &lt; x) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">  i++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>for语句的三个部分（initialize，test，increment），可以省略任何一个，也可以全部省略。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( ; ; )&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。
</code></pre><ol>
<li><p>do…while循环</p>
<p> do…while循环与while循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">  statement</div><div class="line"><span class="keyword">while</span> (expression);</div><div class="line"></div><div class="line"><span class="comment">// 或者</span></div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">  statement</div><div class="line">&#125; <span class="keyword">while</span> (expression);</div></pre></td></tr></table></figure>
<pre><code>不管条件是否为真，do..while循环至少运行一次，这是这种结构最大的特点。另外，while语句后面的分号不能省略。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">do</span> &#123;</div><div class="line">	  <span class="built_in">console</span>.log(i);</div><div class="line">	  i++;</div><div class="line">	&#125; <span class="keyword">while</span>(i &lt; x);</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line">	</div><div class="line">4. break语句和continue语句</div><div class="line"></div><div class="line">	break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行。</div><div class="line">	</div><div class="line">	&gt; break语句用于跳出代码块或循环。</div><div class="line">	</div><div class="line">`<span class="string">``</span> js</div><div class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="keyword">while</span>(i &lt; <span class="number">100</span>) &#123;</div><div class="line">	  <span class="built_in">console</span>.log(<span class="string">'i当前为：'</span> + i);</div><div class="line">	  i++;</div><div class="line">	  <span class="keyword">if</span> (i === <span class="number">10</span>) <span class="keyword">break</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<pre><code>上面代码只会执行10次循环，一旦i等于10，就会跳出循环。

for循环也可以使用break语句跳出循环。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>)</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure>
<pre><code>上面代码执行到i等于3，就会跳出循环

&gt; continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span> (i &lt; <span class="number">100</span>)&#123;</div><div class="line">  i++;</div><div class="line">  <span class="keyword">if</span> (i%<span class="number">2</span> === <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'i当前为：'</span> + i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。

&gt; 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。
</code></pre><ol>
<li><p>标签（label）</p>
<p> JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下:</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">label:</div><div class="line">  statement</div></pre></td></tr></table></figure>
<pre><code>&gt; 标签可以是任意的标识符，但是不能是保留字，语句部分可以是任意语句。

标签通常与break语句和continue语句配合使用，跳出特定的循环。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">top:</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</div><div class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">break</span> top;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// i=0, j=0</span></div><div class="line"><span class="comment">// i=0, j=1</span></div><div class="line"><span class="comment">// i=0, j=2</span></div><div class="line"><span class="comment">// i=1, j=0</span></div></pre></td></tr></table></figure>
<pre><code>上面代码为一个双重循环区块，break命令后面加上了top标签（注意，top不用加引号），满足条件时，直接跳出双层循环。如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。

&gt; continue语句也可以与标签配合使用。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">top:</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)&#123;</div><div class="line">      <span class="keyword">if</span> (i === <span class="number">1</span> &amp;&amp; j === <span class="number">1</span>) <span class="keyword">continue</span> top;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'i='</span> + i + <span class="string">', j='</span> + j);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"><span class="comment">// i=0, j=0</span></div><div class="line"><span class="comment">// i=0, j=1</span></div><div class="line"><span class="comment">// i=0, j=2</span></div><div class="line"><span class="comment">// i=1, j=0</span></div><div class="line"><span class="comment">// i=2, j=0</span></div><div class="line"><span class="comment">// i=2, j=1</span></div><div class="line"><span class="comment">// i=2, j=2</span></div></pre></td></tr></table></figure>
<pre><code>上面代码中，continue命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果continue语句后面不使用标签，则只能进入下一轮的内层循环。
</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>以上就是js里面最常用的循环用法了，不同的循环方式适应不同的场景，比如在循环之前就需要执行一次代码的，使用do…while要比其他的方便许多，当然，自己喜欢用别的也可以，看个人喜好了。欢迎讨论循环的各种用法，多多指教。</p>
]]></content>
    
    <summary type="html">
    
      Javascript中的循环结构及语法分析，几种循环的区别与相同点
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用Dva手脚架搭建React项目</title>
    <link href="http://yoursite.com/2017/06/22/react-summary/"/>
    <id>http://yoursite.com/2017/06/22/react-summary/</id>
    <published>2017-06-22T02:27:33.000Z</published>
    <updated>2017-06-22T08:32:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近开发了一个新项目，这次并没有自己去构建目录和文件，而是使用了react的一个手脚架dva-cli工具部署的文件及目录，不得不说，使用这个工具开发起来还是很方便的。对于这次的开发，我做一下总结，来谈谈这次开发过程中遇到的坑和如何解决这些坑。<br><a id="more"></a></p>
<p>在开发新项目之前，本人就对<a href="https://ant.design/index-cn" target="_blank" rel="external">Ant Design</a>这个项目很关注了，它拥有丰富、灵活、实用的基础组件，为业务产品提供强有力的设计支持。不得不说的是，它的组件库相当丰富，基本上满足了需求。</p>
<p>在了解了这些之后，我们就要基于Ant Design来开发我们的项目了，关于react项目的构建脚手架实在太多，我这里不多说，我直接选用了<a href="https://github.com/dvajs/dva-cli" target="_blank" rel="external">dva-cli</a>，选择它的理由就是它使用起来简单方便，不用自己另外再去配置webpack，只需将现有的配置文件稍作修改就可以了。</p>
<p>既然使用了dva-cli这种脚手架，那么<a href="https://github.com/dvajs/dva" target="_blank" rel="external">dva</a>的知识点就必需掌握了，因为开发过程中肯定会用到。不多说，大家自行搜索资料吧。</p>
<p>接下来直接点，构建项目：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># Install</div><div class="line">$ npm install dva-cli -g</div><div class="line"></div><div class="line"># Create app</div><div class="line">$ dva new myapp</div><div class="line"></div><div class="line"># Start app</div><div class="line">$ cd myapp</div><div class="line">$ npm start</div></pre></td></tr></table></figure>
<p><strong>全局安装dva-cli是很有必要的，不然后面的命令运行不起来。另外，dva-cli使用<a href="https://github.com/sorrycc/roadhog" target="_blank" rel="external">roadhog</a> 来启动本地服务和打包项目的，详细文档可以查看 <a href="https://github.com/sorrycc/roadhog/blob/master/README_en-us.md#configuration" target="_blank" rel="external">roadhog文档</a>。</strong></p>
<h3 id="下面是使用dva命令生成的目录树"><a href="#下面是使用dva命令生成的目录树" class="headerlink" title="下面是使用dva命令生成的目录树"></a>下面是使用dva命令生成的目录树</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">├── mock</div><div class="line">    └── mockData.js        <span class="comment">#</span></div><div class="line">├── src                    <span class="comment"># Source directory</span></div><div class="line">    ├── assets             <span class="comment"># Store images, icons, ...</span></div><div class="line">    ├── components         <span class="comment"># UI components</span></div><div class="line">    ├── index.css          <span class="comment"># CSS for entry file</span></div><div class="line">    ├── index.html         <span class="comment"># HTML for entry file</span></div><div class="line">    ├── index.js           <span class="comment"># Enry file</span></div><div class="line">    ├── models             <span class="comment"># Dva models</span></div><div class="line">    ├── router.js          <span class="comment"># Router configuration</span></div><div class="line">    ├── routes             <span class="comment"># Route components</span></div><div class="line">    ├── services           <span class="comment"># Used for communicate with server</span></div><div class="line">    └── utils              <span class="comment"># Utils</span></div><div class="line">        └── request.js     <span class="comment"># A util wrapped dva/fetch</span></div><div class="line">├── .editorconfig          <span class="comment">#</span></div><div class="line">├── .eslintrc              <span class="comment"># Eslint config</span></div><div class="line">├── .gitignore             <span class="comment">#</span></div><div class="line">├── .roadhogrc             <span class="comment"># Roadhog config</span></div><div class="line">└── package.json           <span class="comment">#</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/dvajs/dva/blob/master/docs/API.md" target="_blank" rel="external">dva的api全在这里的了</a></p>
<p>以上只是简单的生成了一个项目目录，具体怎么脱离后端提供的接口来进行开发。在我的项目中，我使用了<a href="http://mockjs.com/" target="_blank" rel="external">Mock</a>功能，并且roadhog也支持mock功能。使用mock,对于前端来说并不用等待后端给我提供接口，而是先与后端开发人员接口地址以及返回的数据结构和对应字段后，就可以使用Mock直接造数据和接口了。</p>
<p>前端开发的整个过程都是在Mock环境下进行的，并不需要后端提供真实接口。😏这样就大大提高了前端的开发效率（节省了等待接口的过程，不过后期还是要配合后端的真实接口联调的）。</p>
<p>下面给一个介绍一下Mock的配置文件.roadhogrc.mock.js是怎么设置的（生成随机数据，拦截 Ajax 请求）:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> mockData <span class="keyword">from</span> <span class="string">'./mock/mockData'</span>;  <span class="comment">// 引入mock的数据</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">	<span class="string">'GET /api/path/**'</span>: mockData</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是简单的一个例子，从对应的mock文件中引入对应的数据，然后模拟接口。</p>
<p>接下来配置.roadhogrc.js文件，这是roadhog的配置文件，主要是配置代理，本地可直接调用后端真实接口获得数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> onlineTarget = <span class="string">'http://online.com'</span>;  <span class="comment">// 线上项目地址域名</span></div><div class="line"><span class="keyword">const</span> offlineTarget = <span class="string">'http://dev.com'</span>;  <span class="comment">// 测试环境项目地址域名</span></div><div class="line"><span class="keyword">const</span> ProxyConfig = &#123;</div><div class="line">	<span class="comment">// 是否开启代理访问真实接口</span></div><div class="line">    proxy: <span class="literal">true</span>,  </div><div class="line">    <span class="comment">// 是否访问线上接口，如果代理关闭，这项无效，若代理开启，此项为true则访问线上，反之访问测试环境</span></div><div class="line">    online: <span class="literal">false</span>  </div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</div><div class="line">    <span class="string">"entry"</span>: <span class="string">"src/index.js"</span>,</div><div class="line">    <span class="string">"extraBabelPlugins"</span>: [</div><div class="line">        <span class="string">"transform-runtime"</span>,</div><div class="line">        [<span class="string">"import"</span>, &#123; <span class="string">"libraryName"</span>: <span class="string">"antd"</span>, <span class="string">"style"</span>: <span class="literal">true</span> &#125;],</div><div class="line">        <span class="string">"add-module-exports"</span></div><div class="line">    ],</div><div class="line">    <span class="string">"env"</span>: &#123;</div><div class="line">        <span class="string">"development"</span>: &#123;</div><div class="line">            <span class="string">"extraBabelPlugins"</span>: [</div><div class="line">                <span class="string">"dva-hmr"</span>,</div><div class="line">                <span class="string">"babel-plugin-dva-hmr"</span></div><div class="line">            ],</div><div class="line">            <span class="string">"proxy"</span>: ProxyConfig.proxy</div><div class="line">                    ? &#123;</div><div class="line">                        <span class="string">"/api/*"</span>: &#123;</div><div class="line">                            <span class="string">"target"</span>: ProxyConfig.online ? onlineTarget : offlineTarget,</div><div class="line">                            <span class="string">"changeOrigin"</span>: <span class="literal">true</span>,</div><div class="line">                            <span class="string">"secure"</span>:<span class="literal">false</span>,</div><div class="line">                            <span class="string">"ws"</span>: <span class="literal">true</span>,</div><div class="line">                            <span class="string">"headers"</span>: &#123;</div><div class="line">                                <span class="string">"origin"</span>: ProxyConfig.online ? onlineTarget : offlineTarget,</div><div class="line">                                <span class="string">"Referer"</span>: ProxyConfig.online ? onlineTarget : offlineTarget</div><div class="line">                            &#125;</div><div class="line">                        &#125;,</div><div class="line">                        <span class="string">"/exhibitionservice/*"</span>: &#123;</div><div class="line">                          <span class="string">"target"</span>: <span class="string">"http://localhost:8060/"</span>,</div><div class="line">                          <span class="string">"changeOrigin"</span>: <span class="literal">true</span>,</div><div class="line">                          <span class="string">"secure"</span>:<span class="literal">false</span>,</div><div class="line">                          <span class="string">"ws"</span>: <span class="literal">true</span>,</div><div class="line">                          <span class="string">"headers"</span>: &#123;</div><div class="line">                            <span class="string">"origin"</span>: ProxyConfig.online ? onlineTarget : offlineTarget,</div><div class="line">                            <span class="string">"Referer"</span>: ProxyConfig.online ? onlineTarget : offlineTarget</div><div class="line">                          &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    : &#123;&#125;,</div><div class="line">        &#125;,</div><div class="line">        <span class="string">"production"</span>: &#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"theme"</span>: <span class="string">"./theme.config.js"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在完成了以上配置后，前端才能开始项目的开发了，这些都是在开发前的准备。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>前端开始开发前的工作一定要做好，不然后期开发过程中可能会存在各种问题。我在这次的新项目开发中也踩到了不少坑，在后期的分享中再说一说哪坑，我是怎么解决这些坑的。组件化开发很好，不过也会带来很多问题，后面再细说。</p>
]]></content>
    
    <summary type="html">
    
      开发可扩展Web应用,React+Redux+React-router，基于DVA构建React项目
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="React.js" scheme="http://yoursite.com/tags/React-js/"/>
    
  </entry>
  
  <entry>
    <title>正确理解JS中的变量赋值</title>
    <link href="http://yoursite.com/2017/06/14/variable/"/>
    <id>http://yoursite.com/2017/06/14/variable/</id>
    <published>2017-06-14T03:51:14.000Z</published>
    <updated>2017-06-14T03:54:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正确理解JS中的变量赋值"><a href="#正确理解JS中的变量赋值" class="headerlink" title="正确理解JS中的变量赋值"></a>正确理解JS中的变量赋值</h1><p>简单理解就是数字和字符串是复制，对象和数组是地址引用。但如果是引用，如果你对参数进行重新赋值的话，会改变参数引用的地址。函数外部的数组或者对象就不会被修改。<br><a id="more"></a></p>
<p>在看到上面这句话之前，本来我是对变量赋值的概念还不是很理解的，因为最开始我就直接认为变量赋值就是字面上的复制;然而在最近的一次新项目开发中，遇到了一个变量赋值的问题，让我对变量赋值的概念有了不一样的理解，我就又直接的认为变量赋值就是地址引用。但是，这特么也是错误的理解。虽然之前对这样的理解充满着疑惑，也没有去查阅资料去解决心中的问题，就这样让这个知识点从我脑中遗失了。</p>
<p>由于最近几天想脑补一下JS的基础知识，提升自己的基础知识水平，所以又重新开始翻阅各种资料追根朔源。今天在群里的某大神帮助下，基本上算是比较透彻的理解了变量赋值。简单的一句话，说出了变量赋值的原理：</p>
<blockquote>
<p>简单理解就是数字和字符串是复制，对象和数组是地址引用。但如果是引用，如果你对参数进行重新赋值的话，会改变参数引用的地址。函数外部的数组或者对象就不会被修改。</p>
</blockquote>
<p>下面写几个例子，验证一下JS的变量赋值到底是怎样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line"></div><div class="line">b++;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// return 3;</span></div><div class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// return 4;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="string">'string'</span>;</div><div class="line"><span class="keyword">var</span> d = c;</div><div class="line"></div><div class="line">c += <span class="string">' is String'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(c);  <span class="comment">// return 'string is String';</span></div><div class="line"><span class="built_in">console</span>.log(d);  <span class="comment">// return 'string';</span></div></pre></td></tr></table></figure>
<p>此时，从上面的例子可以看出，虽然b的值加1，但是a的值没有改变，另外，c变量有一个字符串拼接过程，但d的值没有变化。从而说明数字和字符串类型的变量赋值就是复制过程。</p>
<p>下面再验证一下对象Object和数组Array变量的赋值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> brr = arr;</div><div class="line"></div><div class="line">brr.push(<span class="number">4</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// return [1,2,3,4]</span></div><div class="line"><span class="built_in">console</span>.log(brr);  <span class="comment">// return [1,2,3,4]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">var</span> obj2 = obj;</div><div class="line"></div><div class="line">obj.c = <span class="number">3</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj);  <span class="comment">// return &#123;a: 1, b: 2, c: 3&#125;;</span></div><div class="line"><span class="built_in">console</span>.log(obj2);  <span class="comment">// return &#123;a: 1, b: 2, c: 3&#125;;</span></div></pre></td></tr></table></figure>
<p>此时，从上面的例子可以得出一个结论，那就是对象Object类型与数组Array类型的变量赋值，是一个地址引用的过程。</p>
<p>接下来就是验证一下对参数进行重新赋值，是否会改变参数引用的地址，而函数外部的数组或者对象就不会被修改。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"></div><div class="line"><span class="comment">// function change(a) &#123;</span></div><div class="line"><span class="comment">//	a.push(4);</span></div><div class="line"><span class="comment">//	return a;</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">	a = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//var brr = change(arr);</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> crr = set(arr);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// return [1,2,3]</span></div><div class="line"><span class="comment">//console.log(brr);  // return [1,2,3,4]</span></div><div class="line"><span class="built_in">console</span>.log(crr);  <span class="comment">// return [3,2,1]</span></div></pre></td></tr></table></figure>
<p>从上面两个例子的结果可以看出，数组Array类型的变量赋值的确是地址的引用，然后如果作为一个函数的参数被引用后被重新赋值了，那么函数外部的数组或者对象就不会被修改了，因而参数引用的地址发生了改变。如果引用的参数在函数内并不是赋值，而是修改参数里的某个属性的话，则参数引用地址不会发生变化，外部的变量属性值也会随之发生变化。</p>
<p>接下来的对象Object类型的变量赋值跟数组Array类型一样，你可以亲手去验证一下，这里不再举例了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于变量的理解，一定要理解透彻，不然在平时写的代码中会出现意想不到的结果，从而让自己陷入困境。在真正理解了变量赋值的过程和原理后，才能在自己的代码中运用自如，规避各种坑。<br>用简单的一句总结变量赋值的过程和原理：数字和字符串类型的变量赋值即复制过程，对象Object类型和数组Array类型的变量赋值即地址引用。但如果是引用，如果你对参数进行重新赋值的话，会改变参数引用的地址。函数外部的数组或者对象就不会被修改。</p>
]]></content>
    
    <summary type="html">
    
      JS中的变量赋值过程和原理，透彻理解JS的变量赋值与原理
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数参数详解</title>
    <link href="http://yoursite.com/2017/02/12/function-arguments/"/>
    <id>http://yoursite.com/2017/02/12/function-arguments/</id>
    <published>2017-02-12T12:21:45.000Z</published>
    <updated>2017-02-13T09:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，有很多时候，开发者没搞清楚函数参数，而随意传递参数，这可能会给函数增加很多不必须的参数，那么这次来细说一下这个函数使用过程的参数的使用。<br><a id="more"></a><br>先看下面这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">a = <span class="number">42</span>, b = a + b + <span class="number">5</span></span>)</span>&#123;</div><div class="line">	<span class="comment">// ..</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>b = a + b + 5 在参数b(=右边的b，而不是函数外的那个)的TDZ中访问b，所以会出错。而访问a却没出错，因为此时刚好跨出了参数a的TDZ。<br>在ES6中，如果参数被省略或者值为undefined，则取该参数的默认值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"> a = <span class="number">42</span>, b = a + <span class="number">1</span></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(a, b);</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo();					<span class="comment">// 42  43</span></div><div class="line">foo(<span class="literal">undefined</span>)		<span class="comment">// 42  43</span></div><div class="line">foo(<span class="number">5</span>)					<span class="comment">// 5  6</span></div><div class="line">foo(<span class="keyword">void</span> <span class="number">0</span>, <span class="number">7</span>)		<span class="comment">// 42  7</span></div><div class="line">foo(<span class="literal">null</span>)				<span class="comment">// null 1</span></div></pre></td></tr></table></figure>
<blockquote>
<p>表达式中 a + 1 中的null被强制类型转换为0.</p>
</blockquote>
<p>对ES6中的参数默认值而言，参数被省略或被赋值为undefined效果都一样，都是取该参数的默认值。然而某些情况下，它们之间还是有区别的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a = <span class="number">42</span>, b = a + <span class="number">1</span></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(</div><div class="line">		<span class="built_in">arguments</span>.length,</div><div class="line">		a, b,</div><div class="line">		<span class="built_in">arguments</span>[<span class="number">0</span>],</div><div class="line">		<span class="built_in">arguments</span>[<span class="number">1</span>]</div><div class="line">	)</div><div class="line">&#125;</div><div class="line">foo();						<span class="comment">// 0  42  43  undefined undefined</span></div><div class="line">foo(<span class="number">10</span>);					<span class="comment">// 1  10  11 10  undefined</span></div><div class="line">foo(<span class="number">10</span>, <span class="literal">undefined</span>);		<span class="comment">// 2  10  11 10  undefined</span></div><div class="line">foo(<span class="number">10</span>, <span class="literal">null</span>);			<span class="comment">// 2  10  null  10  null</span></div></pre></td></tr></table></figure>
<p>虽然参数a和b都有默认值，但是函数不带参数时，arguments数组为空。<br>相反，如果向函数传递undefined值，则arguments数组中会出现一个值为undefined的单元，而不是默认值。</p>
<p>ES6参数默认会导致arguments数组和相对应的命名参数之间出现偏差，ES5也会出现这种情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">	a = <span class="number">42</span>;</div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>);		<span class="comment">// 42 (linked)</span></div><div class="line">foo();			<span class="comment">//undefined (not linked)</span></div></pre></td></tr></table></figure>
<p>向函数中传递参数是，arguments数组中的对应单元会和命名参数建立关联（linkage）以得到相同的值。相反，不传递参数就不会建立关联。</p>
<p>但是，在严格模式中并没有建立关联这一说：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line"><span class="meta">	"use strict"</span>;</div><div class="line">	a = <span class="number">42</span>;</div><div class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</div><div class="line">&#125;</div><div class="line">foo(<span class="number">2</span>);			<span class="comment">// 2 (not linked)</span></div><div class="line">foo(); 			<span class="comment">// undefined (not linked)</span></div></pre></td></tr></table></figure>
<p>因此，在开发中不要依赖这种关联机制。实际上，它是JS语言引擎底层实现的一个抽象泄漏（leaky abstraction），并不是语言本身的特性。</p>
<p>arguments数组已经被废止（特别是在ES6引入剩余参数…之后），不过它并非一无是处。</p>
<p>在ES6之前，获得函数所有参数的唯一途径就是arguments数组。此外，即使将命名参数和arguments数组滥用也不会出错，只需遵守一个原则，即「不要同时访问命名参数和其对应的arguments数组单元」。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log( a + <span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//安全</span></div><div class="line">&#125;</div><div class="line">foo(<span class="number">10</span>,<span class="number">32</span>); <span class="comment">// 42</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      js方法中的参数,js函数的参数详解
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令</title>
    <link href="http://yoursite.com/2017/02/08/GitForstash/"/>
    <id>http://yoursite.com/2017/02/08/GitForstash/</id>
    <published>2017-02-08T12:21:45.000Z</published>
    <updated>2017-02-13T09:43:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>git stash的相关使用，当我们遇到一个紧急bug需要处理，处理完了之后又需要紧急的提交上去，可是目前的工作内容还没有完成，不能在此时提交，想暂存起来。此时，git提供了git stash命令来解决这样的需求。<br><a id="more"></a><br>对git stash的详解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">// 暂存当前状态</div><div class="line">git stash </div><div class="line">=&gt; 后面可带参数 [save message] [-k|--no-keep-index] [--patch]</div><div class="line">// 使用save message 可以对进度添加备注，-k和--no-keep-index指定保存进度后，是否重置暂存区，--patch会显示工作区和HEAD的差异，通过编辑差异文件，排除不需要保存的内容，和git add -p 命令类似。</div><div class="line"></div><div class="line">// 查看当前工作区和版本库区别</div><div class="line">git diff HEAD</div><div class="line">=&gt; 此时若什么都没有输出，说明工作区被重置为HEAD指向内容了</div><div class="line"></div><div class="line">// 显示已暂存列表</div><div class="line">git stash list</div><div class="line"></div><div class="line">//恢复暂存区的工作区的进度</div><div class="line">git stash pop</div><div class="line">=&gt;命令后面可带参数  --index stash@&#123;0&#125;</div><div class="line"></div><div class="line">//不删除已恢复的进度，其他同git stash pop</div><div class="line">git stash apply [--index] [&lt;stash&gt;]</div><div class="line">//删除某一个进度，默认删除最新进度</div><div class="line">git stash drop [&lt;stash&gt;]</div><div class="line">// 删除所有进度</div><div class="line">git stash clear </div><div class="line">// 基于进度创建分支</div><div class="line">git stash branch &lt;branchname&gt; &lt;stash&gt;</div></pre></td></tr></table></figure>
<p>以上就是使用git stash的常用命令了，可是有时候，我们可能会将缓存区的进度给删除了，然而会造成本地写好的工作进度全没了，这确实是一件很头疼的事情</p>
<blockquote>
<p>So,下面再说说将删除后的进度恢复的常用git操作</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 首先使用</div><div class="line">git fsck --lost-found</div><div class="line">//然后使用git show &lt;stash-id&gt;查看是不是自己想要的进度，</div><div class="line">git show &lt;stash-id&gt;</div><div class="line">//如果是，那就可以执行下面的git merge进行恢复了</div><div class="line">git merge &lt;stash-id&gt;</div></pre></td></tr></table></figure>
<p>这样就能找回刚才一不小心给删除掉的工作进度了。</p>
<p>git常用命令之git checkout修改指定分支的指定文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout origin/branch &lt;filepath&gt;</div><div class="line">// 例子</div><div class="line">git checkout master  // 切换回主分支</div><div class="line">git checkout origin/dev src/js/../*.js  // 将dev分支上的src/js/../*.js目录下的某个js文件覆盖到master</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      git常用命令之git
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs的异步I/O</title>
    <link href="http://yoursite.com/2017/01/10/NodeForIO/"/>
    <id>http://yoursite.com/2017/01/10/NodeForIO/</id>
    <published>2017-01-10T12:21:45.000Z</published>
    <updated>2017-02-13T09:43:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前的开发过程中，都是单线程的，所以当两个请求发起的时候，一个在请求，另一个就必须等待上一个请求完成后才能开始自己的请求，这样就大大的浪费了时间，而且在用户体验上也非常糟糕。<br><a id="more"></a></p>
<blockquote>
<p>NodeJs的异步I/O解决了什么问题？</p>
</blockquote>
<ol>
<li>用户体验</li>
<li>资源分配</li>
<li>异步I/O实现现状</li>
<li>异步I/O与非阻塞I/O</li>
<li>理想的非阻塞异步I/O</li>
<li>事实的异步的I/O</li>
</ol>
<blockquote>
<p>Node的异步I/O</p>
</blockquote>
<ol>
<li>事件循环</li>
<li>观察者</li>
<li>请求对象</li>
<li>执行回调</li>
</ol>
<h2 id="Node的事件循环"><a href="#Node的事件循环" class="headerlink" title="Node的事件循环"></a>Node的事件循环</h2><p>在进程启动时，Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。</p>
<h2 id="Node的观察者"><a href="#Node的观察者" class="headerlink" title="Node的观察者"></a>Node的观察者</h2><p>在每个Tick的过程中，如何判断是否有事件需要处理呢？这里必须要引入的概念是[观察者]。每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。</p>
<p>事件可能来自用户的点击或者加载某些文件时产生，而这些产生的事件都有对应的观察者。在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。观察者将事件进行了分类。</p>
<p>事件循环是一个典型的生产者/消费者模型。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。</p>
<h2 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h2><p>对于一般的（非异步）回调函数，函数由我们自行调用，而对于Node中的异步I/O调用而言，回调函数却不由开发者来调用。那么从我们调用后，到回调函数被执行，中间发生了什么呢？事实上，从JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种中间产物，它叫做请求对象。</p>
<h2 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h2><p>组装好请求对象、送入I/O线程池等待执行，实际上完成了异步I/O的第一部分，回调通知是第二部分。</p>
<p>线程池中的I/O操作调用完毕后，会将获取的结果储存在req-&gt;result属性上，然后调用PostQueuedCompletionStatus()通知IOCP，告知当前对象操作已经完成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PostQueuedCompletionStatus((loop)-&gt;iocp,<span class="number">0</span>,<span class="number">0</span>,&amp;((req)-&gt;overlapped))</div></pre></td></tr></table></figure>
<p>PostQueuedCompletionStatus()方法的作用是向IOCP提交执行状态，并将线程归还线程池。通过PostQueuedCompletionStatus()方法提交的状态，可以通过GetQueuedCompletionStatus()提取。</p>
<p>在这个过程中，我们其实还动用了事件循环的I/O观察者。在每次Tick的执行中，它会调用将请求对象加入到dI/O观察者的队列中，然后将其当做事件处理。</p>
<p>I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的。至此，整个异步I/O的流程完全结束。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p>
]]></content>
    
    <summary type="html">
    
      NodeJs的异步IO
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="NodeJs" scheme="http://yoursite.com/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>js数组方法之Reduce</title>
    <link href="http://yoursite.com/2016/10/19/study-js-1/"/>
    <id>http://yoursite.com/2016/10/19/study-js-1/</id>
    <published>2016-10-19T08:58:57.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>reduce()和reduceRight()方法使用指定的函数将数组元素进行组合，生成单个值，这个生成单个值很重要，开发过程中往往会用到这个值。这在函数式编程中是常见的操作，通常被称为“注入”和“折叠”。<br><a id="more"></a><br>下面先举例说明一下reduce是如何工作的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = a.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y, <span class="number">0</span>);  <span class="comment">// 数组求和</span></div><div class="line"><span class="keyword">var</span> product = a.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x*y, <span class="number">1</span>);  <span class="comment">// 数组求积</span></div><div class="line"><span class="keyword">var</span> max = a.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> (x&gt;y) ? x : y);  <span class="comment">// 求最大值</span></div></pre></td></tr></table></figure></p>
<p>reduce()需要两个参数。第一个是执行化简操作的函数。华简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。在上述的例子中，函数通过加法，乘法或取最大值法的方法组合两个值。第二个参数是一个传递给函数的初始值，此参数是可选的，不传的时候，默认是将数组的第一个作为初始值使用。</p>
<p>reduce()使用的函数与forEach()和map()使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第2~4个参数传递给函数。第一个参数是到目前为止的华简操作累积的结果。第一次调用函数时，第一个参数是一个初始值，它就是传递给reduce()的第二个参数。</p>
<p>另外一点需要我们注意，那就是在空数组上，不带初始值参数调用reduce()将导致类型错误异常。如果调用它的时候只有一个值——数组只有一个元素并且没指定初始值，或者一个空数组并且指定一个初始值——reduce()只是简单地返回那个值而不会调用化简函数。</p>
<p>reduceRight()函数的工作原理跟reduce()一样，不同的是它按照的数组索引的从高到低处理数组。</p>
<p>下面举个使用reduce()函数能快速解决问题的例子，题目如下：</p>
<blockquote>
<p>一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？</p>
</blockquote>
<p>使用reduce()函数就很简单的得到结果了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</div><div class="line">arr.reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x^y);  <span class="comment">// 即可得到答案 4</span></div></pre></td></tr></table></figure></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>为了简单起见，为目前为止，所展示的例子都是数值，但数学的计算不是reduce()和reduceRight()唯一意图。这两个函数可以结合其他函数可以达到意想不到的结果，而且在性能上也可能有大提升。<br>希望大家能提出建议和要求，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      js数组方法
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS算法之找出缺失的整数</title>
    <link href="http://yoursite.com/2016/10/18/study-js-0/"/>
    <id>http://yoursite.com/2016/10/18/study-js-0/</id>
    <published>2016-10-18T06:33:13.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>算法对于一名程序员来说是个硬骨头，很难啃，悲剧的是啃完了还未必有用——除了面试的时候。这不，这次为了要面试，这些天关注各种关于算法的资料，在实际开发中，我也是用的时候才会去用，一般不会涉及到算法。<br>下面直接上题目吧<br><a id="more"></a></p>
<blockquote>
<p>题目：一个无序数组里有99个不重复正整数，范围从1到100，唯独缺少一个整数。如何找出这个缺失的整数？</p>
<p>假设数组长度是N，那么该解法的时间复杂度是O（1），空间复杂度是O（N）。</p>
</blockquote>
<p>此题有多种解法：<br>1、创建一个HashMap，以1到100为键，值都是0 。然后遍历整个数组，每读到一个整数，就找到HashMap当中对应的键，让其值加一。由于数组中缺少一个整数，最终一定有99个键对应的值等于1, 剩下一个键对应的值等于0。遍历修改后的HashMap，找到这个值为0的键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当前的无序数组</span></div><div class="line"><span class="keyword">var</span> DisorderedArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,..<span class="number">.99</span>] <span class="comment">//此处省略</span></div><div class="line"><span class="keyword">var</span> HashMap = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</div><div class="line"><span class="comment">// 遍历HashMap</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; HashMap.length; i++)&#123;</div><div class="line">    HashMap[i] = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 遍历无序数组</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; DisorderedArray.length; j++)&#123;</div><div class="line">    HashMap[j] += <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; HashMap.length; k++)&#123;</div><div class="line">    <span class="keyword">if</span>(HashMap[k] === <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> k;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>以上解法在时间上是最优的，但额外开辟了空间，如何能够降低空间复杂度呢？</p>
</blockquote>
<p>此时，便有了解法2：<br>先把数组元素进行排序，然后遍历数组，检查任意两个相邻元素数值是否是连续的。如果不连续，则中间缺少的整数就是所要寻找的；如果全都连续，则缺少的整数不是1就是100。<br>假设数组长度是N，如果用时间复杂度为O（N<em>LogN）的排序算法进行排序，那么该解法的时间复杂度是O（N</em>LogN），空间复杂度是O（1）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当前的无序数组</span></div><div class="line"><span class="keyword">var</span> DisorderedArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,..<span class="number">.99</span>] <span class="comment">//此处省略</span></div><div class="line">DisorderedArray.sort();</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; DisorderedArray.length; i++)&#123;</div><div class="line">    <span class="keyword">var</span> prev = DisorderedArray[i<span class="number">-1</span>],</div><div class="line">        item = DisorderedArray[i];</div><div class="line">    <span class="keyword">if</span>(item - prev != <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> item<span class="number">-1</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(DisorderedArray[<span class="number">0</span>] == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(DisorderedArray[n] == (DisorderedArray.length<span class="number">-1</span>))&#123;</div><div class="line">            <span class="keyword">return</span> DisorderedArray.length;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上解法是没有开辟额外空间的，但是时间复杂度又大了，有办法让时间和空间都进一步优化么？</p>
</blockquote>
<p>此时，解法3出现：<br>很简单也很高效的方法，先算出1+2+3….+100的和，然后依次减去数组里的元素，最后得到的差，就是唯一缺失的整数。<br>假设数组长度是N，那么该解法的时间复杂度是O（N），空间复杂度是O（1）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> DisorderedArray = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,..<span class="number">.99</span>] <span class="comment">//此处省略</span></div><div class="line"><span class="keyword">var</span> res = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">101</span>; i++)&#123;</div><div class="line">    res += i;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; DisorderedArray.length; j++)&#123;</div><div class="line">    res -= DisorderedArray[j]</div><div class="line">&#125;</div><div class="line"><span class="comment">// 最后这里的res就是最后缺失的整数</span></div></pre></td></tr></table></figure>
<blockquote>
<p>以上解法，对于没有重复元素的数组，这解法在时间和空间上已经是最优了。下面开始扩展问题</p>
<p>题目扩展：一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了偶数次，只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个出现奇数次的整数？</p>
</blockquote>
<p>此扩展的题目来看，用上面的三种方法是没有用的，在这里，就要运用到异或运算，于是就有这了这样的解法：遍历整个数组，依次做异或运算。由于异或在位运算时相同为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次的整数会被留下。</p>
<p>假设数组长度是N，那么该解法的时间复杂度是O（N），空间复杂度是O（1）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// js异或运算符(^)</span></div><div class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>];</div><div class="line"><span class="keyword">var</span> res;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> flag = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</div><div class="line">        <span class="keyword">if</span>(i != j)&#123;</div><div class="line">            <span class="keyword">var</span> aaa = arr[i] ^ arr[j];</div><div class="line">            <span class="keyword">if</span>(!aaa) &#123;</div><div class="line">                flag = <span class="literal">true</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!flag)&#123;</div><div class="line">        res = i;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(res)  <span class="comment">// 5</span></div><div class="line"><span class="built_in">console</span>.log(arr[res])  <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>此处我不得不说一下上面的方法，虽然上面的代码解决了问题，可是还是使用了大题代码，这在性能上还是会有很大的损耗的。于是就有了我下面这段代码，依然可以得到答案，而且大减少了代码量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>];</div><div class="line">arr.reduce(<span class="function">(<span class="params">prev,next</span>) =&gt;</span> prev ^ next); <span class="comment">// 此处得到结果为2</span></div><div class="line"><span class="comment">// 由于异或在位运算时相同为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次的整数会被留下</span></div></pre></td></tr></table></figure>
<blockquote>
<p>题目第二次扩展：一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了偶数次，只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个出现奇数次的整数？</p>
</blockquote>
<p>解法：</p>
<p>遍历整个数组，依次做异或运算。由于数组存在两个出现奇数次的整数，所以最终异或的结果，等同于这两个整数的异或结果。这个结果中，至少会有一个二进制位是1（如果都是0，说明两个数相等，和题目不符）。</p>
<p>举个例子，如果最终异或的结果是5，转换成二进制是00000101。此时我们可以选择任意一个是1的二进制位来分析，比如末位。把两个奇数次出现的整数命名为A和B，如果末位是1，说明A和B转为二进制的末位不同，必定其中一个整数的末位是1，另一个整数的末位是0。</p>
<p>根据这个结论，我们可以把原数组按照二进制的末位不同，分成两部分，一部分的末位是1，一部分的末位是0。由于A和B的末位不同，所以A在其中一部分，B在其中一部分，绝不会出现A和B在同一部分，另一部分没有的情况。</p>
<p>这样一来就简单了，我们的问题又回归到了上一题的情况，按照原先的异或解法，从每一部分中找出唯一的奇数次整数即可。</p>
<p>假设数组长度是N，那么该解法的时间复杂度是O（N）。把数组分成两部分，并不需要借助额外存储空间，完全可以在按二进制位分组的同时来做异或运算，所以空间复杂度仍然是O（1）。</p>
]]></content>
    
    <summary type="html">
    
      js算法
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React项目的文件目录部署</title>
    <link href="http://yoursite.com/2016/10/06/react-study-2/"/>
    <id>http://yoursite.com/2016/10/06/react-study-2/</id>
    <published>2016-10-06T14:38:26.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个从零开始的项目，大家会怎样部署自己的文件目录结构呢，又或者是以一种什么样的目的去构建项目，其实无论使用什么样的技术，一个理想中的 Web 项目大概都需要考虑以下几个方面：<br><a id="more"></a></p>
<ol>
<li>易于开发：在功能开发时，无需关注复杂的技术架构，能够直观的写功能相关的代码。</li>
<li>易于扩展：增加新功能时，无需对已有架构进行调整，新功能和已有功能具有很好的隔离性，并能很好的衔接。新功能的增加并不会带来显著的性能问题。</li>
<li>易于维护：代码直观易读易理解。即使是新加入的开发成员，也能够很快的理解技术架构和代码逻辑。</li>
<li>易于测试：代码单元性好，能够尽量使用纯函数。无需或很少需要 mock 即可完成单元测试。</li>
<li>易于构建：代码和静态资源结构符合主流模式，能够使用标准的构建工具进行构建。无需自己实现复杂的构建逻辑。</li>
</ol>
<p>其实，以上五点看起来很容易，相信大家在构建自己的项目的时候真实往往都是这么想的，可是实际构建项目的时候，可能会无意识的偏离轨道。上面总结的五点是源自于网络，我只是收集起来在这里借鉴一下。然而，这些方面并不是互相独立，而是互相依赖互相制约。当某个方面做到极致，其它点就会受到影响。举例来说，写一个计数器功能，用jQuery一个页面内即可完成，但是易开发了，却不易扩展。因此我们通常都需要根据实际项目情况在这些点之间做一个权衡，达到适合项目的最佳状态。庆幸的是，现在的前端技术快速发展，不断出现的新技术帮助我们在各个方面都获得很大提升。</p>
<p>下面，我再介绍一下，我是如何构建我的React前端项目的。这里强调可扩展，因为传统前端实现方案通常在面对复杂应用时常常力不从心，代码结构容易混乱，性能问题难以解决。而可扩展则意味着能够从项目的初始阶段就具有了支持复杂项目的能力。</p>
<p>关于React项目的开发，我用到了React，Redux，React-router，webpack,babel等等。。。<br>关于React在这里不多说，<a href="https://facebook.github.io/react/" target="_blank" rel="external">React官方网站</a>已经描述的很详细了。那么，我简单说一下Redux，</p>
<blockquote>
<p>Redux 是 JavaScript 程序状态管理框架。尽管是一个通用型的框架，但是和 React 在一起能够更好的工作，因为当状态变化时，React 可以不用关心变化的细节，由虚拟 DOM 机制完成优化过的UI更新逻辑。</p>
</blockquote>
<p>Redux 也被认为整个 React 生态圈最难掌握的技术之一。其 action，reducer 和各种中间件虽然将代码逻辑充分隔离，即常说的 separation of concerns，但在一定程度上也给开发带来了不便。这也是上面提到的，在易维护、易扩展、易测试上得到了提升，那么易开发则受到了影响。</p>
<p>然后再说一下React-router，在开发单页应用的时候，路由是必不可少的，也是极为重要的。正如传统 Web 程序用页面来组织不同的功能模块，由不同的 URL 来区分和导航，单页应用使用 Router 来实现同样的功能，只是在前端进行渲染而不是服务器端。React 应用的“标准”路由方案就是使用 React-router。路由功能不仅让用户更容易使用（例如刷新页面后维持 UI），也能够在开发时让我们思考如何更好组织功能单元，这也是功能复杂之后的必然需求。所以即使一开始的需求很简单，我们也应该引入 React-router 帮助我们以页面为单元进行功能的组织。</p>
<h2 id="下面我们来看如何去构建可扩展的-Web-项目。"><a href="#下面我们来看如何去构建可扩展的-Web-项目。" class="headerlink" title="下面我们来看如何去构建可扩展的 Web 项目。"></a>下面我们来看如何去构建可扩展的 Web 项目。</h2><blockquote>
<p>按功能（feature）来组织文件夹结构</p>
</blockquote>
<p>无论是 Flux 还是 Redux，提供的官方示例都是以技术逻辑来组织文件夹的，例如，下面是 Redux 的 Todo 示例应用的文件夹结构：<br><img src="/img/react-study-2-0.png" alt="Todo 示例应用的文件夹结构"></p>
<p>虽然这种模式在技术上很清晰，在实际项目中却有很大的缺点：</p>
<ol>
<li>难以扩展。当应用功能增加，规模变大时，一个 components 文件夹下可能会有几十上百个文件，组件间的关系极不直观。</li>
<li>难以开发。在开发某个功能时，通常需要同时开发组件，action，reducer 和样式。把它们分布在不同文件夹下严重影响开发效率。尤其是项目复杂之后，不同文件的切换会消耗大量时间。</li>
</ol>
<blockquote>
<p>因此，我使用按功能来组织文件夹的方式，即功能相关的代码放到一个文件夹。例如，对于一个简单论坛程序，可能包含 user，topic，comment 这么几个核心功能。</p>
</blockquote>
<p><img src="/img/react-study-2-1.png" alt="重新构建的文件夹结构"></p>
<p>这种文件夹结构在功能上而非技术上对代码逻辑进行区分，使得应用具有更好的扩展性，当增加新的功能时，只需增加一个新的文件夹即可；删除功能时同理。</p>
<h2 id="使用页面（Page）的概念"><a href="#使用页面（Page）的概念" class="headerlink" title="使用页面（Page）的概念"></a>使用页面（Page）的概念</h2><p>前面提到了路由是当今前端应用的不可缺少的部分之一，那么对应到组件级别，就是页面组件。因此我们在开发的过程中，需要明确定义页面的概念：</p>
<ol>
<li>一个页面拥有自己的 URL 地址。页面的展现和隐藏完全由 React-router 进行控制。当创建一个页面时，通常意味着在路由配置里增加一条新的规则。这和传统 Web 应用非常类似。</li>
<li>一个页面对应 Redux 的容器组件的概念。页面首先是一个标准的 React 组件，其次它通过 react-redux 封装成容器组件从而具备和 Redux 交互的能力。</li>
</ol>
<p>页面是导航的基本模块单元，同时也是同一功能相关 UI 的容器，这种符合传统 Web 开发方式的概念有助于让项目结构更容易理解。</p>
<h2 id="每个-action-一个独立文件"><a href="#每个-action-一个独立文件" class="headerlink" title="每个 action 一个独立文件"></a>每个 action 一个独立文件</h2><p>使用 Redux 来管理状态，就需要进行 action 和 reducer 的开发。在官方示例以及几乎所有的教程中，所有的 action 都放在一个文件，而所有的 reducer 则放在另外的文件。这种做法易于理解但是不具备很好的可扩展性，而且当项目复杂后，action 文件和 reducer 文件都会变得很冗长，不易开发和维护。因此我们使用每个 action 一个独立文件的模式：每个 Redux 的 action 和对应的 reducer 放在同一个文件。使用这个做法的另一个原因是我们发现每次创建完 action 几乎都需要立刻创建 reducer 对其进行处理。把它们放在同一个文件有利于开发效率和维护。</p>
<p>以开发一个计数器组件为例：</p>
<p>action.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> COUNTER_PLUS_ONE = <span class="string">'COUNTER_PLUS_ONE'</span></div></pre></td></tr></table></figure></p>
<p>constants.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    COUNTER_PLUS_ONE</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'./action'</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">counterPlusOne</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">type</span>: COUNTER_PLUS_ONE</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>reducer.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    COUNTER_PLUS_ONE</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'./action'</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state,action</span>)</span>&#123;</div><div class="line">    <span class="keyword">switch</span>(action.type)&#123;</div><div class="line">        <span class="keyword">case</span> COUNTER_PLUS_ONE:</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                ...state,</div><div class="line">                <span class="attr">count</span>: state.count + <span class="number">1</span>;</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> state;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>按我们的经验，大部分的 reducer 都会对应到相应的 action，很少需要跨功能全局使用。因此，将它们放入一个文件是完全合理的，有助于提高开发效率。需要注意的是，这里定义的 reducer 并不是标准的 Redux reducer，因为它没有初始状态（initial state）。它仅仅是被功能文件夹下的根 reducer 调用。注意这个 reducer 固定命名为 “reducer”，从而方便其被自动加载。</p>
<h2 id="使用单文件-action-的好处"><a href="#使用单文件-action-的好处" class="headerlink" title="使用单文件 action 的好处"></a>使用单文件 action 的好处</h2><ol>
<li>易于开发：当创建 action 时，无需在多个文件中跳转</li>
<li>易于维护：因为每个 action 在单独的文件，因此每个文件都很短小，通过文件名就可以定位到相应的功能逻辑；</li>
<li>易于测试：每个 action 都可以使用一个独立的测试文件进行覆盖，测试文件中也是同时包含对 action 和 reducer 的测试； </li>
<li>易于工具化：因为使用 Redux 的应用具有较为复杂的技术结构，我们可以使用工具来自动化一些逻辑。现在我们无需进行语法分析就可以自动生成代码。</li>
<li>易于静态分析：全局的 action 和 reducer 通常意味着模块间的依赖。这时我们只要分析功能文件夹下的 reducer.js，即可以找到所有这些依赖。</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>本文主要介绍了如何使用 React，Redux 以及 React-router 来开发可扩展的 Web 应用。其核心思路有两个，一是以功能（feature）为单位组件文件夹结构；二是采用每个 action 单独文件的模式。这样能够让代码更加模块化，增加和删除功能都不会对其它模块产生太大影响。同时使用 React-router 来帮助实现页面的概念，让单页应用（SPA）也拥有传统 Web 应用的 URL 导航功能，进一步降低了功能模块间的耦合行，让应用结构更加清晰直观。</p>
]]></content>
    
    <summary type="html">
    
      开发可扩展Web应用,React+Redux+React-router
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="React.js" scheme="http://yoursite.com/tags/React-js/"/>
    
  </entry>
  
  <entry>
    <title>函数的递归</title>
    <link href="http://yoursite.com/2016/08/27/Recursion/"/>
    <id>http://yoursite.com/2016/08/27/Recursion/</id>
    <published>2016-08-27T15:30:55.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，解释一下什么是递归——程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。<br><a id="more"></a></p>
<p>下面举一个经典的递归函数的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">return</span> n*f(n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么，根据上面的例子，我们来具体分析一下递归程序的基本步骤：</p>
<ol>
<li>递归就是方法里调用自身。</li>
<li>在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
<li>使用更简单的子问题重新定义答案。我们可以将答案定义为当前节点的内容加上列表中其余部分的和。</li>
<li>合并结果。递归调用之后，我们将当前节点的值加到递归调用的结果上。</li>
</ol>
<p>由于在新项目中的需求，我就想到使用递归函数来实现，问题是这样的：</p>
<blockquote>
<p>给你一个数组，数组的每个元素都是一个对象，需要比较每个元素对象里面的两个属性的值是否相同，如果相同，则合并该元素将里面的count计数属性值相加 </p>
</blockquote>
<p>下面就贴上答案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * uniqueData</div><div class="line"> * arr -&gt; 传入的数组，[注：此数组的每个元素都是一个对象，各元素的属性相同值不同]</div><div class="line"> * field -&gt; 传入比较的属性值，[field是一个数组]</div><div class="line"> * count -&gt; 传递需要处理的属性键，[注；count属性值必须为number，以作统计]</div><div class="line"> * jsonArray -&gt; 存入去重合并后的元素</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">let</span> jsonArray = [];</div><div class="line"><span class="comment">// 去重合并</span></div><div class="line"><span class="keyword">let</span> uniqueData = <span class="function"><span class="keyword">function</span>(<span class="params">arr,field,count</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> narr = arr</div><div class="line">    <span class="keyword">if</span>(narr.length &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">let</span> first = narr.shift();</div><div class="line">        <span class="keyword">if</span>(narr.length &gt; <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">let</span> next = narr.findIndex(<span class="function">(<span class="params">value,index,array</span>)=&gt;</span>&#123;</div><div class="line">                <span class="keyword">return</span> field.map(<span class="function">(<span class="params">val,index</span>)=&gt;</span>&#123;</div><div class="line">                    <span class="keyword">return</span> first[val] == value[val]</div><div class="line">                &#125;).reduce(<span class="function">(<span class="params">prev,next</span>) =&gt;</span> prev&amp;&amp;next )</div><div class="line">            &#125;)</div><div class="line">            <span class="keyword">if</span>(next &gt;= <span class="number">0</span>)&#123;</div><div class="line">                first[count] += <span class="built_in">parseInt</span>(narr[next][count]);</div><div class="line">                narr.splice(next,<span class="number">1</span>);</div><div class="line">                narr.splice(<span class="number">0</span>,<span class="number">0</span>,first);</div><div class="line">                uniqueData(narr,field,count);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                jsonArray.push(first);</div><div class="line">                uniqueData(narr,field,count);</div><div class="line">            &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            jsonArray.push(first)</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        jsonArray.push(narr[<span class="number">0</span>])</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 模拟数据</span></div><div class="line"><span class="keyword">var</span> data = [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">count</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">selected</span>:<span class="number">0</span>,</div><div class="line">        <span class="attr">subselectd</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">stock</span>:<span class="number">22</span></div><div class="line">    &#125;,&#123;</div><div class="line">        <span class="attr">count</span>:<span class="number">2</span>,</div><div class="line">        <span class="attr">selected</span>:<span class="number">0</span>,</div><div class="line">        <span class="attr">subselected</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">stock</span>:<span class="number">22</span></div><div class="line">    &#125;,&#123;</div><div class="line">        <span class="attr">count</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">selected</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">subselected</span>:<span class="number">2</span>,</div><div class="line">        <span class="attr">stock</span>:<span class="number">11</span></div><div class="line">    &#125;,&#123;</div><div class="line">        <span class="attr">count</span>:<span class="number">3</span>,</div><div class="line">        <span class="attr">selected</span>:<span class="number">0</span>,</div><div class="line">        <span class="attr">subselected</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">stock</span>:<span class="number">22</span></div><div class="line">    &#125;,&#123;</div><div class="line">        <span class="attr">count</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">selected</span>:<span class="number">1</span>,</div><div class="line">        <span class="attr">subselected</span>:<span class="number">2</span>,</div><div class="line">        <span class="attr">stock</span>:<span class="number">11</span></div><div class="line">    &#125;</div><div class="line">];</div><div class="line">uniqueData(data,[<span class="string">'selected'</span>,<span class="string">'subselected'</span>],<span class="string">'count'</span>);</div><div class="line"><span class="built_in">console</span>.log(jsonArray);</div></pre></td></tr></table></figure>
<p>可能以上的代码不是最好的方案，如果有比较好的方案，请多多指教，谢谢！</p>
<h2 id="总结递归算法解决问题的特点："><a href="#总结递归算法解决问题的特点：" class="headerlink" title="总结递归算法解决问题的特点："></a>总结递归算法解决问题的特点：</h2><ul>
<li>递归就是方法里调用自身。</li>
<li>在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
<li>递归算法解题通常显得很简洁，但递归算法解题的运行效率较低。所以一般不提倡用递归算法设计程序。</li>
<li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等，所以一般不提倡用递归算法设计程序。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      函数的递归
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>事件绑定</title>
    <link href="http://yoursite.com/2016/08/07/react-study-1/"/>
    <id>http://yoursite.com/2016/08/07/react-study-1/</id>
    <published>2016-08-07T07:06:51.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>在文章开头先提一下React的事件绑定，React 里只需把事件处理器（event handler）以骆峰命名（camelCased）形式当作组件的 props 传入即可，就像使用普通 HTML 那样。React 内部创建一套合成事件系统来使所有事件在 IE8 和以上浏览器表现一致。也就是说，React 知道如何冒泡和捕获事件，而且你的事件处理器接收到的 events 参数与 W3C 规范 一致，无论你使用哪种浏览器。<br><a id="more"></a></p>
<blockquote>
<p>如果需要在手机或平板等触摸设备上使用 React，需要调用 React.initializeTouchEvents(true); 启用触摸事件处理。<br>在后续的一篇文章中，我将详细说明一下关于React事件的绑定及最大化公用事件</p>
</blockquote>
<h2 id="自动绑定和事件代理"><a href="#自动绑定和事件代理" class="headerlink" title="自动绑定和事件代理"></a>自动绑定和事件代理</h2><p>实际上，React 做了一些操作来让代码高效运行且易于理解。</p>
<ul>
<li>Autobinding: 在 JavaScript 里创建回调的时候，为了保证 this 的正确性，一般都需要显式地绑定方法到它的实例上。有了 React，所有方法被自动绑定到了它的组件实例上。React 还缓存这些绑定方法，所以 CPU 和内存都是非常高效。而且还能减少打字！</li>
<li>事件代理 ： React 实际并没有把事件处理器绑定到节点本身。当 React 启动的时候，它在最外层使用唯一一个事件监听器处理所有事件。当组件被加载和卸载时，只是在内部映射里添加或删除事件处理器。当事件触发，React 根据映射来决定如何分发。当映射里处理器时，会当作空操作处理。参考 <a href="https://davidwalsh.name/event-delegate" target="_blank" rel="external">David Walsh</a> 很棒的文章 了解这样做高效的原因。</li>
</ul>
<p>在JavaScript中，事件委托是一种很常用也很合理的方法。事件委托可以让你避免添加事件监听器监听特定的节点，相反，事件委托是将事件紧监听放在父级节点上。该事件监听冒泡事件，找到子元素进行匹配。下面举个例子来说明一下事件委托的工作原理：</p>
<p>首先，我们有一些子元素的你UL元素：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"parent-list"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-1"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-2"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-3"</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-4"</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-5"</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"post-6"</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们也说，有什么需要点击每个子元素时发生。你可以将单独的事件侦听器添加到每个LI元素，但如果LI元素被频繁的从列表中添加和删除呢？添加和删除事件侦听器将是一场噩梦，尤其是如果添加和移除代码在Li的应用程序中不同的地方。更好的解决方案是一个事件监听器添加到父UL元素。但是，如果你添加事件监听到父UL，你将如何知道被点击哪些元素？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get the element, add a click listener...</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"parent-list"</span>).addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="comment">// e.target is the clicked element!</span></div><div class="line">    <span class="comment">// If it was a list item</span></div><div class="line">    <span class="keyword">if</span>(e.target &amp;&amp; e.target.nodeName == <span class="string">"LI"</span>) &#123;</div><div class="line">        <span class="comment">// List item found!  Output the ID!</span></div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"List item "</span>, e.target.id.replace(<span class="string">"post-"</span>, <span class="string">""</span>), <span class="string">" was clicked!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过增加一个click事件侦听父元素开始。当事件听者被触发，检查事件元件，以确保它的元素反应以类型。如果它是一个LI元素，但是，如果这不是我们想要的元素，该事件可以被忽略。这个例子是非常简单 -  UL和LI是一个直接的比较。让我们尝试一些更加困难。让我们多子元素的父级DIV ，但我们关心的是与ClassA的CSS类的标记</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Get the parent DIV, add click listener...</span></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="comment">// e.target was the clicked element</span></div><div class="line">  <span class="keyword">if</span> (e.target &amp;&amp; e.target.matches(<span class="string">"a.classA"</span>)) &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Anchor element clicked!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>使用<a href="https://davidwalsh.name/element-matches-selector" target="_blank" rel="external">Element.matches</a> API ，我们可以看到，如果匹配元素我们所期望的目标。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>由于大多数开发者使用JavaScript库为他们的DOM元素和事件处理，我建议使用事件委托的方法，因为它们能够进行高效的事件委托和元素监听。<br>此外，希望这篇文章能够帮助你直观的理解事件委托的概念，并能让你知道事件委托的高效。</p>
]]></content>
    
    <summary type="html">
    
      事件绑定
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="React.js" scheme="http://yoursite.com/tags/React-js/"/>
    
  </entry>
  
  <entry>
    <title>hexo常用命令</title>
    <link href="http://yoursite.com/2016/07/14/hexo-command/"/>
    <id>http://yoursite.com/2016/07/14/hexo-command/</id>
    <published>2016-07-14T12:21:45.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久没来写博客了，感觉一下子对hexo的命令生疏了不少，所以才有了这篇文章，下面罗列一下关于hexo的一些常用的命令<br><a id="more"></a></p>
<blockquote>
<p>hexo的安装、升级以及初始化</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">npm install hexo -g  #安装</div><div class="line">npm update hexo -g  #升级</div><div class="line">hexo init  #初始化</div></pre></td></tr></table></figure>
<blockquote>
<p>hexo命令的简写方式，使用简写可以省下不少事</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo n "博客名称"  =&gt; hexo new "博客名称"   #这两个都是创建新文章，前者是简写模式</div><div class="line">hexo p  =&gt; hexo publish </div><div class="line">hexo g  =&gt; hexo generate  #生成</div><div class="line">hexo s  =&gt; hexo server  #启动服务预览</div><div class="line">hexo d  =&gt; hexo deploy  #部署</div></pre></td></tr></table></figure>
<blockquote>
<p>关于hexo的服务器命令</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hexo server   #Hexo 会监视文件变动并自动更新，无须重启服务器。</div><div class="line">hexo server -s   #静态模式</div><div class="line">hexo server -p 5000   #更改端口</div><div class="line">hexo server -i 192.168.1.1   #自定义IP</div><div class="line">hexo clean   #清除缓存，网页正常情况下可以忽略此条命令</div><div class="line">hexo g   #生成静态网页</div><div class="line">hexo d   #开始部署</div></pre></td></tr></table></figure>
<blockquote>
<p>监视文件变动</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo generate   #使用Hexo生成静态文件</div><div class="line">hexo generate --watch   #监视文件变动</div></pre></td></tr></table></figure>
<blockquote>
<p>模版</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">title: 使用Hexo搭建个人博客</div><div class="line">layout: post</div><div class="line">date: <span class="number">2014</span><span class="number">-03</span><span class="number">-03</span> <span class="number">19</span>:<span class="number">07</span>:<span class="number">43</span></div><div class="line">comments: <span class="literal">true</span></div><div class="line">categories: Blog</div><div class="line">tags: [Hexo]</div><div class="line">keywords: Hexo, Blog</div><div class="line">description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。</div></pre></td></tr></table></figure>
<blockquote>
<p>设置文章摘要，即更多按钮</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">以上是文章摘要&lt;!-- more --&gt;以下是余下全文</div></pre></td></tr></table></figure>
<blockquote>
<p>关于模版里的一些变量</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">变量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:title</td>
<td style="text-align:left">标题</td>
</tr>
<tr>
<td style="text-align:left">:year</td>
<td style="text-align:left">建立的年份（4 位数）</td>
</tr>
<tr>
<td style="text-align:left">:month</td>
<td style="text-align:left">建立的月份（2 位数）</td>
</tr>
<tr>
<td style="text-align:left">:i_month</td>
<td style="text-align:left">建立的月份（去掉开头的零）</td>
</tr>
<tr>
<td style="text-align:left">:day</td>
<td style="text-align:left">建立的日期（2 位数）</td>
</tr>
<tr>
<td style="text-align:left">:i_day</td>
<td style="text-align:left">建立的日期（去掉开头的零）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于搭建hexo博客中的一些报错的解决方法</p>
</blockquote>
<ol>
<li>找不到git部署<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR Deployer not found : git</div></pre></td></tr></table></figure>
</li>
</ol>
<p>解决方案<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<ol>
<li>部署类型设置git</li>
</ol>
<p>hexo 3.0 部署类型不再是github,而是修改_config.yml文件，如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: http://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: git@***.github.com:***/***.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      hexo常用命令，帮助使用hexo搭建博客。
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>React.js学习笔记(一)初尝react.js魅力</title>
    <link href="http://yoursite.com/2016/05/04/react-study-0/"/>
    <id>http://yoursite.com/2016/05/04/react-study-0/</id>
    <published>2016-05-04T14:01:51.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天只是初尝react.js的魅力，先不作深究。<br>关于react.js，在前端界一直是一个热门话题。我也是一直想去尝试使用这一框架开发项目，只可惜工作的原因一直未得愿。由于，接下来的工作项目中，前端需要重新架构，所以，我就想用react.js这套框架来搭建前端框架用来快速开发。<br><a id="more"></a></p>
<h2 id="HTML-模板"><a href="#HTML-模板" class="headerlink" title="HTML 模板"></a>HTML 模板</h2><p>首先，需要建立好目录结构，然后在相应的目录下创建相应的html模板，使用React的网页源码，结构如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"build/react.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"build/react-dom.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="javascript"></span></div><div class="line">      ReactDOM.render(</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</div><div class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</div><div class="line">      );</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>上面代码有两个地方需要注意。首先，最后一个 script 标签的 type 属性为 text/babel 。这是因为 React独有的 JSX 语法，跟 JavaScript 不兼容。凡是使用 JSX 的地方，都要加上 type=’text/babel’。<br>其次，上面代码一共用了三个库： react.js 、react-dom.js 和 Browser.js ，它们必须首先加载。其中，react.js 是 React 的核心库，react-dom.js 是提供与 DOM 相关的功能，Browser.js 的作用是将 JSX 语法转为 JavaScript 语法，这一步很消耗时间，实际上线的时候，应该将它放到服务器完成。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ babel src --out-dir build</div></pre></td></tr></table></figure>
<p>上面命令可以将 src 子目录的 js 文件进行语法转换，转码后的文件全部放在 build 子目录.</p>
<h2 id="ReactDOM-render"><a href="#ReactDOM-render" class="headerlink" title="ReactDOM.render()"></a>ReactDOM.render()</h2><p>ReactDOM.render 是 React 的最基本方法，用于将模板转为 HTML 语言，并插入指定的 DOM 节点。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<h2 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h2><p>HTML 语言直接写在 JavaScript 语言之中，不加任何引号，这就是 JSX 的语法，它允许 HTML 与 JavaScript 的混写.<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> names = [<span class="string">'Alice'</span>, <span class="string">'Emily'</span>, <span class="string">'Kate'</span>];</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">  &#123;</div><div class="line">    names.map(function (name) &#123;</div><div class="line">      return <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>上面代码体现了 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。上面代码的运行结果如下。</p>
<blockquote>
<p>JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员（查看</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var arr = [</div><div class="line">  &lt;h1&gt;Hello world!&lt;/h1&gt;,</div><div class="line">  &lt;h2&gt;React is awesome&lt;/h2&gt;,</div><div class="line">];</div><div class="line">ReactDOM.render(</div><div class="line">  &lt;div&gt;&#123;arr&#125;&lt;/div&gt;,</div><div class="line">  document.getElementById('example')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上面代码的arr变量是一个数组，结果 JSX 会把它的所有成员，添加到模板</p>
]]></content>
    
    <summary type="html">
    
      初尝react.js魅力
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="React.js" scheme="http://yoursite.com/tags/React-js/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS核心模块笔记(九)文件系统 fs</title>
    <link href="http://yoursite.com/2016/05/03/node-study-8/"/>
    <id>http://yoursite.com/2016/05/03/node-study-8/</id>
    <published>2016-05-03T14:52:03.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。与其他模块不同的是， fs 模块中所有的操作都提供了异步的和同步的两个版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的fs.readFileSync()。我们以几个函数为代表，介绍 fs 常用的功能，并列出 fs 所有函数的定义和功能。<br><a id="more"></a></p>
<h2 id="fs-readFile"><a href="#fs-readFile" class="headerlink" title="fs.readFile"></a>fs.readFile</h2><p>fs.readFile(filename,[encoding],[callback(err,data)])是最简单的读取文件的函数。它接受一个必选参数 filename，表示要读取的文件名。第二个参数 encoding是可选的，表示文件的字符编码。 callback 是回调函数，用于接收文件的内容。如果不指定 encoding，则 callback 就是第二个参数。回调函数提供两个参数 err 和 data， err 表示有没有错误发生， data 是文件内容。如果指定了 encoding， data 是一个解析后的字符串，否则 data 将会是以 Buffer 形式表示的二进制数据。<br>先来看一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.readFile(<span class="string">'content.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data);</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>首先，假设content.txt中的内容是UTF-8编码的Text文本文件，则运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Buffer 54 65 78 74 20 e6 96 87 e6 9c ac e6 96 87 e4 bb b6 e7 a4 ba e4 be 8b&gt;</div></pre></td></tr></table></figure></p>
<p>上面的输出结果表示的是程序以二进制的模式读取了文件的内容，data的值是Buffer对象。<br>如果给fs.readFile的encoding指定编码，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.readFile(<span class="string">'content.txt'</span>,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(data);</div><div class="line">    &#125;;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>这样子，输出的结果会是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Text 文本文件示例。</div></pre></td></tr></table></figure></p>
<p>当读取文件出现错误时， err 将会是 Error 对象。如果 content.txt不存在，运行前面的代码则会出现以下结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; [<span class="built_in">Error</span>: ENOENT, no such file or directory <span class="string">'content.txt'</span>] errno: <span class="number">34</span>, <span class="attr">code</span>: <span class="string">'ENOENT'</span>,<span class="attr">path</span>: <span class="string">'content.txt'</span> &#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Node.js 的异步编程接口习惯是以函数的最后一个参数为回调函数，通常一个函数只有一个回调函数。回调函数是实际参数中第一个是 err，其余的参数是其他返回的内容。如果没有发生错误， err 的值会是 null 或undefined。如果有错误发生， err 通常是 Error 对象的实例。</p>
</blockquote>
<h2 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync"></a>fs.readFileSync</h2><p>fs.readFileSync(filename, [encoding])是 fs.readFile 同步的版本。它接受的参数和 fs.readFile 相同，而读取到的文件内容会以函数返回值的形式返回。如果有错误发生， fs 将会抛出异常，你需要使用 try 和 catch 捕捉并处理异常。</p>
<blockquote>
<p>与同步 I/O 函数不同， Node.js 中异步函数大多没有返回值。</p>
</blockquote>
<h2 id="fs-open"><a href="#fs-open" class="headerlink" title="fs.open"></a>fs.open</h2><p>fs.open(path, flags, [mode], [callback(err, fd)])是 POSIX open 函数的封装，与 C 语言标准库中的 fopen 函数类似。它接受两个必选参数， path 为文件的路径，flags 可以是以下值</p>
<ul>
<li>r ：以读取模式打开文件。</li>
<li>r+ ：以读写模式打开文件。</li>
<li>w ：以写入模式打开文件，如果文件不存在则创建。</li>
<li>w+ ：以读写模式打开文件，如果文件不存在则创建。</li>
<li>a ：以追加模式打开文件，如果文件不存在则创建。</li>
<li>a+ ：以读取追加模式打开文件，如果文件不存在则创建。</li>
</ul>
<p>mode 参数用于创建文件时给文件指定权限，默认是 0666①。回调函数将会传递一个文件描述符 fd②。</p>
<blockquote>
<p>① 文件权限指的是 POSIX 操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如 0754 表示文件所有者的权限是 7 （读、写、执行），同组的用户权限是 5 （读、执行），其他用户的权限是 4 （读），写成字符表示就是 -rwxr-xr–。<br>② 文件描述符是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。</p>
</blockquote>
<h2 id="fs-read"><a href="#fs-read" class="headerlink" title="fs.read"></a>fs.read</h2><p>fs.read(fd, buffer, offset, length, position, [callback(err, bytesRead,buffer)])是 POSIX read 函数的封装，相比 fs.readFile 提供了更底层的接口。fs.read的功能是从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象。 offset 是buffer 的写入偏移量。 length 是要从文件中读取的字节数。 position 是文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。回调函数传递bytesRead 和 buffer，分别表示读取的字节数和缓冲区对象。</p>
<p>然后，看一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line">fs.open(<span class="string">'content.txt'</span>,<span class="string">'r'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,fd</span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="built_in">console</span>.error(err);</div><div class="line">        <span class="keyword">return</span> ;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">8</span>);</div><div class="line">    sf.read(fd,buf,<span class="number">0</span>,<span class="number">8</span>,<span class="literal">null</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytesRead,buffer</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(err)&#123;</div><div class="line">            <span class="built_in">console</span>.error(err);</div><div class="line">            <span class="keyword">return</span> ;</div><div class="line">        &#125;;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'bytesRead: '</span> + bytesRead);</div><div class="line">        <span class="built_in">console</span>.log(buffer);</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>上面的代码最终运行结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bytesRead: <span class="number">8</span></div><div class="line">&lt;Buffer <span class="number">54</span> <span class="number">65</span> <span class="number">78</span> <span class="number">74</span> <span class="number">20</span> e6 <span class="number">96</span> <span class="number">87</span>&gt;</div></pre></td></tr></table></figure></p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>一般来说，除非必要，否则不要使用这种方式读取文件，因为它要求你手动管理缓冲区和文件指针，尤其是在你不知道文件大小的时候，这将会是一件很麻烦的事情。</p>
]]></content>
    
    <summary type="html">
    
      Node.js文件系统 fs
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS核心模块笔记(八)事件驱动 events</title>
    <link href="http://yoursite.com/2016/05/02/node-study-7/"/>
    <id>http://yoursite.com/2016/05/02/node-study-7/</id>
    <published>2016-05-02T14:14:13.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-js的事件驱动-events"><a href="#Node-js的事件驱动-events" class="headerlink" title="Node.js的事件驱动 events"></a>Node.js的事件驱动 events</h2><p>events 是 Node.js 最重要的模块，没有“之一”，原因是 Node.js 本身架构就是事件式的，而它提供了唯一的接口，所以堪称 Node.js 事件编程的基石。 events 模块不仅用于用户代码与 Node.js 下层事件循环的交互，还几乎被所有的模块依赖。<br><a id="more"></a></p>
<h2 id="事件发射器"><a href="#事件发射器" class="headerlink" title="事件发射器"></a>事件发射器</h2><p>events 模块只提供了一个对象： events.EventEmitter。 EventEmitter 的核心就是事件发射与事件监听器功能的封装。EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件， EventEmitter 支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br>先来看个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</div><div class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter();</div><div class="line">emitter.on(<span class="string">'someEvent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">arg1,arg2</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'linstener1'</span>,arg1,arg2);</div><div class="line">&#125;);</div><div class="line">emitter.on(<span class="string">'someEvent'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">arg1,arg2</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2);</div><div class="line">&#125;);</div><div class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'xiege'</span>, <span class="number">1989</span>);</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">listener1 xiege <span class="number">1989</span></div><div class="line">listener2 xiege <span class="number">1989</span></div></pre></td></tr></table></figure></p>
<p>分析下以上js代码：</p>
<blockquote>
<p>emitter 为事件 someEvent 注册了两个事件监听器，然后发射了someEvent事件。运行结果中可以看到两个事件监听器回调函数被先后调用。</p>
</blockquote>
<p>上面就是EventEmitter最简单的用法，接下来，列出EventEmitter常用的API：</p>
<ul>
<li>EventEmitter.on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener。</li>
<li>EventEmitter.emit(event, [arg1], [arg2], […])发射event事件，传递若干可选参数到事件监听器的参数表。</li>
<li>EventEmitter.once(event, listener)为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。</li>
<li>EventEmitter.removeListener(event, listener)移除指定事件的某个监听器，listener必须是该事件已经注册过的监听器。</li>
<li>EventEmitter.removeAllListeners([event])移除所有事件的所有监听器，如果指定event，则移除指定事件的所有监听器。</li>
</ul>
<h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了“错误”的语义，我们在遇到异常的时候通常会发射 error 事件。当 error 被发射时， EventEmitter 规定如果没有响应的监听器， Node.js 会把它当作异常，退出程序并打印调用栈。我们一般要为会发射 error事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>
<h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、 net、http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。<br>为什么要这样做呢？原因有两点。首先，具有某个实体功能的对象实现事件符合语义，事件的监听和发射应该是一个对象的方法。其次 JavaScript 的对象机制是基于原型的，支持部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
]]></content>
    
    <summary type="html">
    
      Node.js事件驱动 events
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS核心模块笔记(七)常用工具 util</title>
    <link href="http://yoursite.com/2016/05/01/node-study-6/"/>
    <id>http://yoursite.com/2016/05/01/node-study-6/</id>
    <published>2016-05-01T13:48:30.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用工具-util"><a href="#常用工具-util" class="headerlink" title="常用工具 util"></a>常用工具 util</h2><p>util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能过于精简的不足。<br><a id="more"></a></p>
<blockquote>
<p>util.inherits</p>
</blockquote>
<p>util.inherits(constructor, superConstructor)是一个实现对象间原型继承的函数。 JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。 JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的，<br>首先介绍一下util.inherits的用法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'base'</span>;</div><div class="line">    <span class="keyword">this</span>.base = <span class="number">1989</span>;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">this</span>.name);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">Base.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'sub'</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">util.inherits(Sub,Base);</div><div class="line"></div><div class="line"><span class="keyword">var</span> objBase = <span class="keyword">new</span> Base();</div><div class="line">objBase.showName();</div><div class="line">objBase.sayHello();</div><div class="line"><span class="built_in">console</span>.log(objBase);</div><div class="line"></div><div class="line"><span class="keyword">var</span> objSub = <span class="keyword">new</span> Sub();</div><div class="line">objSub.showName();</div><div class="line"><span class="comment">// objSub.sayHello();</span></div><div class="line"><span class="built_in">console</span>.log(objSub);</div></pre></td></tr></table></figure></p>
<p>下面分析一下代码：</p>
<blockquote>
<p>首先定义了一个基础对象Base和一个继承自Base的Sub对象，Base有三个在构造函数内定义的属性和一个原型中定义的函数，通过util.inherits实现继承。</p>
</blockquote>
<p>运行结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">base</div><div class="line">Hello base</div><div class="line">&#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'base'</span>,</div><div class="line">    <span class="attr">base</span>:<span class="number">1989</span>,</div><div class="line">    <span class="attr">sayHello</span>:[<span class="built_in">Function</span>]</div><div class="line">&#125;</div><div class="line">sub</div><div class="line">&#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'sub'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：Sub仅仅继承了Base在原型中定义的函数，而构造函数内部创造的base属性和sayHello函数都没有被Sub继承。同时，在原型中定义的属性不会被console.log作为对象的属性输出。这就是为为什么在代码中注释掉objSub.sayHello()这行的原因，不然会报错。</p>
</blockquote>
<h2 id="util-inspect"><a href="#util-inspect" class="headerlink" title="util.inspect"></a>util.inspect</h2><p>util.inspect(object,[showHidden],[depth],[colors])是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。<br>对它的的参数下面简要列出一下：</p>
<ul>
<li>接受一个参数object，即要转换的对象。</li>
<li>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。</li>
<li>depth 表示最大递归的层数<ul>
<li>如果对象很复杂，你可以指定层数以控制输出信息的多少。</li>
<li>如果不指定depth，默认会递归2层，</li>
<li>指定为 null 表示将不限递归层数完整遍历对象。</li>
</ul>
</li>
<li>如果color 值为 true，输出格式将会以 ANSI 颜色编码，通常用于在终端显示更漂亮的效果。</li>
</ul>
<blockquote>
<p>特别要指出的是， util.inspect 并不会简单地直接把对象转换为字符串，即使该对象定义了 toString 方法也不会调用。</p>
</blockquote>
<p>看下面这个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'xiege'</span>;</div><div class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person();</div><div class="line"><span class="built_in">console</span>.log(util.inspect(obj));</div><div class="line"><span class="built_in">console</span>.log(util.inspect(obj,<span class="literal">true</span>));</div></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">name</span>:<span class="string">'xiege'</span>,</div><div class="line">    <span class="attr">toString</span>:[<span class="built_in">Function</span>]</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    <span class="attr">toString</span>:&#123;</div><div class="line">        [<span class="built_in">Function</span>][prototype]:&#123;[<span class="keyword">constructor</span>]:[Circular]&#125;,</div><div class="line">        [caller]:null,</div><div class="line">        [length]:0,</div><div class="line">        [name]:'',</div><div class="line">        [arguments]:null</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    name:'xiege'</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>除了以上说到的几个函数外，util还提供了util.isArray()、util.isRegExp()、util.isDate()、util.isError()四个类型测试工具，以及util.format()、util.debug()等工具。</p>
]]></content>
    
    <summary type="html">
    
      Node.js常用工具之util
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS核心模块笔记(六)全局对象</title>
    <link href="http://yoursite.com/2016/04/30/node-study-5/"/>
    <id>http://yoursite.com/2016/04/30/node-study-5/</id>
    <published>2016-04-30T15:03:30.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始，才是真正的接触到了node.js的核心部分，那就是node.js的核心模块。核心模块是 Node.js 的心脏，它由一些精简而高效的库组成，为 Node.js提供了基本的API。接下来，将选出最常用的核心模块加以详细介绍，主要内容包括：<br><a id="more"></a></p>
<ul>
<li>全局对象，</li>
<li>常用工具，</li>
<li>事件机制，</li>
<li>文件系统访问，</li>
<li>HTTP服务器与客户端。</li>
</ul>
<h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象，而 Node.js 中的全局对象是 global，所有全局变量（除了global本身以外）都是global对象的属性。<br>我们在 Node.js 中能够直接访问到对象通常都是 global 的属性，如 console、process等，下面逐一介绍。</p>
<h2 id="全局对象与全局变量"><a href="#全局对象与全局变量" class="headerlink" title="全局对象与全局变量"></a>全局对象与全局变量</h2><p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条件的变量是全局变量：</p>
<ul>
<li>在最外层定义的变量，</li>
<li>全局对象的属性，</li>
<li>隐式定义的变量(未定义直接赋值的变量)。</li>
</ul>
<p>当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注意的是，在 Node.js中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。</p>
<blockquote>
<p>永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</p>
</blockquote>
<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>process 是一个全局变量，即 global 对象的属性。它用于描述当前 Node.js进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p>
<ol>
<li>process.argv是命令行参数数组，第一个元素是 node， 第二个元素是脚本文件名，从第三个元素开始每个元素是一个运行参数。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(process.argv);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>将以上代码存储为argv.js,通过以下命令运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node argv.js 1991 name=byviod --v &quot;Carbo kuo&quot;</div></pre></td></tr></table></figure></p>
<ol>
<li>process.stdout是标准输出流，通常我们是使用console.log()向标准输出打印字符，process.stdout.write()函数提供了更底层的接口。</li>
<li>process.stdin是标准输入流，初始时它的是被暂停的，要想从标准输入读取数据，你必须恢复流，并手动编写流的事件响应函数。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.stdin.resume();</div><div class="line">process.stdin.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    process.stdout.write(<span class="string">'read from console:'</span> + data.toString());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<ol>
<li>process.nextTick(callback)的功能是为事件循环设置一项任务，Node.js会在下次事件循环调响应时调用callback.</li>
</ol>
<h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。 Node.js 沿用了这个标准，提供与习惯行为一致的console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。</p>
<ul>
<li>console.log()：向标准输出流打印字符并以换行符结束。 console.log 接受若干个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则以类似于 C 语言 printf() 命令的格式输出。第一个参数是一个字符串，如果没有参数，只打印一个换行。</li>
<li>console.error()：与 console.log() 用法相同，只是向标准错误流输出。</li>
<li>console.trace()：向标准错误流输出当前的调用栈。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      Node.js调试
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS学习笔记(五)调试</title>
    <link href="http://yoursite.com/2016/04/29/node-study-4/"/>
    <id>http://yoursite.com/2016/04/29/node-study-4/</id>
    <published>2016-04-29T14:43:20.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>写程序时免不了遇到 bug，Node.js的调试功能正是由V8提供的，保持了一贯的高效和方便的特性。尽管你也许已经对原始的调试方式十分适应，而且有了一套高效的调试技巧，但今天还是要介绍一下Node.js内置的工具和第三方模块来进行单步调试。<br><a id="more"></a></p>
<h2 id="命令行调试"><a href="#命令行调试" class="headerlink" title="命令行调试"></a>命令行调试</h2><blockquote>
<p>Node.js支持命令行下的单步调试，下面来介绍一个简单的例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="string">'world'</span>;</div><div class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + x + a);</div><div class="line">&#125;;</div><div class="line">c(b);</div></pre></td></tr></table></figure>
<p>在命令行下执行 node debug debug.js,将会启动调试工具</p>
<h2 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h2><blockquote>
<p>V8 提供的调试功能是基于 TCP 协议的，因此 Node.js 可以轻松地实现远程调试。在命令行下使用以下两个语句之一可以打开调试服务器：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">node --debug[=port] script.js</div><div class="line">node --debug-brk[=port] script.js</div></pre></td></tr></table></figure>
<p>node –debug 命令选项可以启动调试服务器，默认情况下调试端口是 5858，也可以使用 –debug=1234 指定调试端口为 1234。使用 –debug 选项运行脚本时，脚本会正常执行，但不会暂停，在执行过程中调试客户端可以连接到调试服务器。如果要求脚本暂停执行等待客户端连接，则应该使用 –debug-brk 选项。这时调试服务器在启动后会立刻暂停执行脚本，等待调试客户端连接。</p>
<blockquote>
<p>事实上，当使用 node debug debug.js 命令调试时，只不过是用 Node.js 命令行工具将自动完成相关任务。</p>
</blockquote>
<h2 id="使用-node-inspector-调试-Node-js"><a href="#使用-node-inspector-调试-Node-js" class="headerlink" title="使用 node-inspector 调试 Node.js"></a>使用 node-inspector 调试 Node.js</h2><p>大部分基于 Node.js 的应用都是运行在浏览器中的，例如强大的调试工具 node-inspector。node-inspector 是一个完全基于 Node.js 的开源在线调试工具，提供了强大的调试功能和友好的用户界面，它的使用方法十分简便。<br>首先，使用以下命令安装node-inspector,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g node-inspector</div></pre></td></tr></table></figure></p>
<p>然后在终端中通过以下命令连接需要除错的脚本调试服务器,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node --debug-bre=5858 debug.js</div></pre></td></tr></table></figure></p>
<p>进而启动node-inspector:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node-inspector</div></pre></td></tr></table></figure></p>
<p>在浏览器中打开 <a href="http://127.0.0.1:8080/debug?port=5858" target="_blank" rel="external">http://127.0.0.1:8080/debug?port=5858</a> ，即可显示出优雅的 Web 调试工具。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>node-inspector 的使用方法十分简单，和浏览器脚本调试工具一样，支持单步、断点、调用栈帧查看等功能。无论你以前有没有使用过调试工具，都可以在几分钟以内轻松掌握。<br>另外，需要我们注意的是：</p>
<blockquote>
<p>node-inspector 使用了 WebKit Web Inspector，因此只能在 Chrome、Safari等 WebKit 内核的浏览器中使用，而不支持 Firefox 或 Internet Explorer。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      Node.js调试
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS学习笔记(四)包</title>
    <link href="http://yoursite.com/2016/04/28/node-study-3/"/>
    <id>http://yoursite.com/2016/04/28/node-study-3/</id>
    <published>2016-04-28T13:52:15.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于Node.js的包的理解，是非常抽象的。对于这个，我刚开始接触的时候，也是一头雾水，那先来看看Node.js里面是怎么定义包的。<br>包是模块基础上更深一步的抽象，Node.js的包类似C/C++的函数库或者Java/.Net的类库。它的将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node.js根据CommonJS规范实现了包机制，开发了npm来解决包的发布和获取需求。<br><a id="more"></a></p>
<blockquote>
<p>Node.js的包是一个目录，其中包含一个JSON格式的包说明文件pagkage.json。严格符合CommonJS规范的包应该具备以下特征：</p>
</blockquote>
<ul>
<li>package.json必须在包的顶层目录下;</li>
<li>二进制文件应该在bin目录下;</li>
<li>JavaScript代码应该在lib目录下;</li>
<li>文档应该在doc目录下;</li>
<li>单元测试应该在test目录下。</li>
</ul>
<p>Node.js对包的要求并没有这么严格，只要顶层目录下有package.json，并符合一些规范即可。当然为了提高兼容性，还是建议在制作包的时候，严格遵守CommonJS规范。</p>
<h2 id="作为文件夹的模块"><a href="#作为文件夹的模块" class="headerlink" title="作为文件夹的模块"></a>作为文件夹的模块</h2><p>模块与文件是一一对应的。文件不仅可以是JavaScript代码或二进制代码，还可以是一个文件夹。最简单的包，就是一个作为文件夹的模块。下面我们举个例子，创建一个somepackage的文件夹，然后在其中创建index.js文件，内容如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// somepackage/index.js</span></div><div class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后在somepackage文件夹之外创建一个getpackage.js文件，内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getpackage.js</span></div><div class="line"><span class="keyword">var</span> somepackage = <span class="built_in">require</span>(<span class="string">'./somepackage'</span>);</div><div class="line">somepackage.hello();</div></pre></td></tr></table></figure></p>
<p>运行node getpackage.js,控制台将输出结果：hello.<br>我们使用这种方法可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制package.json,我们可以创建更复杂、更完善、更符合规范的包用于发布。</p>
<blockquote>
<p>细说package.json</p>
</blockquote>
<p>在前面例子中的 somepackage 文件夹下，我们创建一个叫做 package.json 的文件，内容如下所示：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"main"</span>:<span class="string">"./lib/interface.js"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后将index.js重命名为interface.js并放入lib子文件夹下，然后我将interface.js里面的输出内容改为hello,mood!。以同样的方式再次调用这个包，依然可以正常使用。终端输出结果为：hello,mood!</p>
<blockquote>
<p>Node.js 在调用某个包时，会首先检查包中 package.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p>
</blockquote>
<p>package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段:</p>
<ul>
<li>name:包的名称，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。</li>
<li>description：包的简要说明。</li>
<li>version：符合语义化版本识别规范的版本字符串。</li>
<li>keywords：关键字数组，通常用于搜索。</li>
<li>maintainers：维护者数组，每个元素要包含 name、 email （可选）、 web （可选）字段。</li>
<li>contributors：贡献者数组，格式与maintainers相同。包的作者应该是贡献者数组的第一个元素。</li>
<li>bugs:提交bug的地址，可以是网址或者电子邮件地址。</li>
<li>licenses：许可证数组，每个元素要包含 type （许可证的名称）和 url （链接到许可证文本的地址）字段。</li>
<li>repositories：仓库托管地址数组，每个元素要包含 type（仓库的类型，如 git ）、url （仓库的地址）和 path （相对于仓库的路径，可选）字段。</li>
<li>dependencies：包的依赖，一个关联数组，由包名称和版本号组成。</li>
</ul>
<p>现在，给出一个完全符合CommonJS规范的package.json示例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">"name"</span>:<span class="string">"mypackage"</span>,</div><div class="line">    <span class="attr">"description"</span>:<span class="string">"Sample package for CommonJS. This package demonstrates the required elements of a CommonJS package."</span>,</div><div class="line">    <span class="attr">"version"</span>:<span class="string">"0.7.0"</span>,</div><div class="line">    <span class="attr">"keywords"</span>:[</div><div class="line">        <span class="string">"package"</span>,</div><div class="line">        <span class="string">"example"</span></div><div class="line">    ],</div><div class="line">    <span class="attr">"maintainers"</span>:[</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"name"</span>:<span class="string">"Springxiegel"</span>,</div><div class="line">            <span class="attr">"email"</span>:<span class="string">"springxiege@sina.cn"</span></div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"contributors"</span>:[</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"name"</span>:<span class="string">"XieGe"</span>,</div><div class="line">            <span class="attr">"web"</span>:<span class="string">"http://springxiege.github.io"</span></div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"bugs"</span>:&#123;</div><div class="line">        <span class="attr">"mail"</span>:<span class="string">"1953744343@qq.com"</span>,</div><div class="line">        <span class="attr">"web"</span>:<span class="string">"http://springxiege.github.io"</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">"licenses"</span>:[</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"type"</span>:<span class="string">"GPLv2"</span>,</div><div class="line">            <span class="attr">"url"</span>:<span class="string">"http://springxiege.github.io"</span></div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"repositories"</span>:[</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"type"</span>:<span class="string">"get"</span>,</div><div class="line">            <span class="attr">"url"</span>:<span class="string">"http://springxiege.github.io"</span></div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">"dependencies"</span>:[</div><div class="line">        &#123;</div><div class="line">            <span class="attr">"webkit"</span>:<span class="string">"1.2"</span>,</div><div class="line">            <span class="attr">"ssl"</span>:&#123;</div><div class="line">                <span class="attr">"gnutls"</span>:[<span class="string">"1.0"</span>,<span class="string">"2.0"</span>],</div><div class="line">                <span class="attr">"openssl"</span>:<span class="string">"0.9.8"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="？疑问：如果将package-json里面的main字段改成sub字段，但是我又想获取sub字段的模块，该怎么获取呢？"><a href="#？疑问：如果将package-json里面的main字段改成sub字段，但是我又想获取sub字段的模块，该怎么获取呢？" class="headerlink" title="？疑问：如果将package.json里面的main字段改成sub字段，但是我又想获取sub字段的模块，该怎么获取呢？"></a>？疑问：如果将package.json里面的main字段改成sub字段，但是我又想获取sub字段的模块，该怎么获取呢？</h2><p>对于这个疑问，我也是一头雾水弄不明白，看来只能搞搞清楚后再作解答了。</p>
]]></content>
    
    <summary type="html">
    
      Node.js模块和包
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS学习笔记(三)模块</title>
    <link href="http://yoursite.com/2016/04/27/node-study-2/"/>
    <id>http://yoursite.com/2016/04/27/node-study-2/</id>
    <published>2016-04-27T15:08:03.000Z</published>
    <updated>2017-02-13T08:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>模块（Module）和包（Package）是 Node.js最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正是为了实现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的script 标签来实现。 Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。<br><a id="more"></a></p>
<h2 id="什么是模块？"><a href="#什么是模块？" class="headerlink" title="什么是模块？"></a>什么是模块？</h2><p>模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、 JSON 或者编译过的 C/C++ 扩展。下面就是我们调用一个模块的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div></pre></td></tr></table></figure></p>
<p>其中 http是 Node.js的一个核心模块，其内部是用C++实现的，外部用JavaScript封装。只是需要通过require函数获取这个模块，然后才有使用其中的对象。</p>
<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>在 Node.js 中，创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问题仅仅在于如何在其他文件中获取这个模块。 Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口， require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。<br>首先，创建一个module.js文件，内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//module.js</span></div><div class="line"><span class="keyword">var</span> name;</div><div class="line">exports.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>)</span>&#123;</div><div class="line">    name = thyName;</div><div class="line">&#125;;</div><div class="line">exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后在同一目录下创建一个getmodule.js文件，内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// getmodule.js</span></div><div class="line"><span class="keyword">var</span> myModules = <span class="built_in">require</span>(<span class="string">'./module'</span>);</div><div class="line">myModules.setName(<span class="string">'心情'</span>);</div><div class="line">myModules.sayHello();</div></pre></td></tr></table></figure></p>
<p>最后运行的结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello心情</div></pre></td></tr></table></figure></p>
<p>在以上示例中， module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访问接口，在 getmodule.js 中通过 require(‘./module’) 加载这个模块，然后就可以直接访问 module.js 中 exports 对象的成员函数了。<br>现在，我将上面的module.js文件内容修改一下，内容如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// module.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> name;</div><div class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>)</span>&#123;</div><div class="line">        name = thyName;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'hello'</span> + name);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">module</span>.exports = hello;</div><div class="line"></div><div class="line"><span class="comment">// getmodule.js</span></div><div class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">'./module.js'</span>);</div><div class="line">_hello = <span class="keyword">new</span> hello();</div><div class="line">_hello.setName(<span class="string">'心情'</span>);</div><div class="line">_hello.sayHello();</div></pre></td></tr></table></figure></p>
<p>最后输出的结果是一样的。事实上， exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本质上是通过它为模块闭包①的内部建立了一个有限的访问接口。因为它没有任何特殊的地方，所以可以用其他东西来代替，譬如我们上面例子中的 Hello 对象。</p>
<h2 id="警告："><a href="#警告：" class="headerlink" title="警告："></a>警告：</h2><p>不可以通过对 exports 直接赋值代替对 module.exports 赋值。exports 实际上只是一个和 module.exports 指向同一个对象的变量，它本身会在模块执行结束后释放，但 module 不会，因此只能通过指定module.exports 来改变访问接口。</p>
]]></content>
    
    <summary type="html">
    
      Node.js模块和包
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="NodeJS" scheme="http://yoursite.com/tags/NodeJS/"/>
    
  </entry>
  
</feed>
